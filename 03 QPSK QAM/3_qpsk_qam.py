# -*- coding: utf-8 -*-
"""3 QPSK QAM.ipynb

Automatically generated by Colaboratory.



# 3 QPSK QAM
"""

from google.colab import drive
drive.mount('/content/drive')

path = "/content/drive/My Drive/Colab Notebooks"

"""## Pythonのバージョン確認と，必要なライブラリをインポートする．"""

!python3 --version

import random

import matplotlib as makeMSL
import matplotlib.pyplot as plt
import numpy as np
import math

"""以下は$\mbox{erfc}$関数を読み込むためのライブラリ"""

from scipy import special
from scipy.linalg import sqrtm

"""## 通信モデルに基づいたシミュレーション用のモジュール

*  情報源
*  情報源符号器
*  通信路符号器
*  通信路
*  白色ガウス雑音
*  通信路複復号器
*  情報源復号器

### 情報源
numpy.randomでも代用可
"""

'''
情報源クラス
'''
class InformationSource:
  def __init__(self,
                 N = 9,   #次数
                 a = 4, b = 9 #帰還タップ
                 ):
    self.N = N
    self.a = a
    self.b = b

  
  '''
  乱数(M系列)を発生させる
  @param informationSize int             発生させる乱数の個数
  @return information     numpy.ndarray 乱数
  '''
  def outputInformation(self, informationSize):
    information = np.empty(informationSize, dtype = int)

    for i in range(informationSize):
      if i < self.N :
        information[i] = random.randrange(2)
      else :
        information[i] = information[i - self.a] ^ information[i - self.b]

    return information

"""### 情報源符号器"""

'''
情報源符号器
'''
class Encoder:
  '''
  @param M int 符号のビット数
  '''
  def __init__(self,
               M #符号のビット数
               ) :
    self.M = M

    #２進数のマスク
    self.mask = np.array([1 << bit for bit in range(M)])
  
  '''
  0/1乱数をM[bit]の符号にする
  @param information numpy.ndarray 0/1の乱数(情報)
  @return data        numpy.ndarray 符号
  '''
  def encode(self,
             information):
    information2 = np.concatenate([information, information])

    data = np.array([
        self.mask @ information2[i: i + self.M] 
        for i in range(information.size)
    ])
    data = np.reshape(data, (1, data.size))

    return data

    return np.array([
        np.array([self.mask @ information2[i: i + self.M] ])
        for i in range(information.size)
    ])
    
    '''
    return np.array([
        self.mask @ information2[i: i + self.M]
        for i in range(information.size)
    ])
    '''

"""### 通信路符号器

Mは単位が[bit]とする
**MPSKのとき**$$\mathbb{Z} \mapsto \mathbb{C}:x\mapsto \sqrt{P_s} \cdot  \exp\Big(j\frac{2\pi}{2^M}x\Big)$$  <br>

**MQAMのとき**<br>データ$x$を上位ビット$x^U$，下位ビット$x^L$に分けて
$$
f:\times2d - (2^{M/2} - 1)d
$$
を作用させてそれぞれ複素信号$s$の実部$s^I$と虚部$s^Q$とする． <br>
ただし$2d$は信号点間隔であり，電力$\mathbb{E}\big[|s|^2\big]$を$P_S$に固定するとき
$$
P_S = 
\frac{1}{2^M} \cdot
\sum_{x \in \{0, 1, \cdots 2^M - 1\} }
  \Bigg\| f(x^U) + jf(x^L) \Bigg\|^2
$$

より$d$は以下のように確定する.

$$
d = \sqrt{\frac{3}{2} \frac{P_S}{2^M - 1 } }
$$
"""

'''
通信路符号器
'''
class Modulator:
  '''
  constructor
  @param M              int   多値数[bit] 単位がビットであることに注意
  @param mode          str   変調方式 ex) mode = "PSK", mode = "QAM"
  @param isGrayCode    bool  グレイコードにするか否か
  @param powerOfSignal float １シンボルあたりの送信電力 (１ビットあたりの送信電力ではない！)
  '''
  def __init__(self,
               M,
               mode,
               isGrayCode = True,
               powerOfSignal  = 1.0
               ):
    
    self.M = M
    self.mode = mode
    self.isGrayCode = isGrayCode
    self.powerOfSignal = powerOfSignal

    if mode == "QAM":
      self.d = math.sqrt(
          1.5 * self.powerOfSignal / ( (1 << self.M) - 1 )
      )
    
    elif mode == "PSK":
      self.A  = math.sqrt( self.powerOfSignal )

  '''
  変調
  @param data     np.ndarray データ
  @return symbol  np.ndarray シンボル
  '''
  def modulate(self,data):
    if self.mode == "PSK":
      if self.isGrayCode == True:
        data = self.grayEncode(data)
      return self.A * np.exp(1j * 2.0 * np.pi/ (1 << self.M) * data)
    
    if self.mode == "QAM":
      x_U = self.sliceUpperBit(data)
      if self.isGrayCode == True:
        x_U = self.grayEncode(x_U)

      x_L = self.sliceLowerBit(data)
      if self.isGrayCode  == True:
        x_L = self.grayEncode(x_L)

      s_I = self.f(x_U)
      s_Q = self.f(x_L)
      return s_I + 1j * s_Q
  
  '''
  上位ビット取得
  @param x    np.ndarray {0, 1, ..., 2^M - 1} データ
  @return x_U np.ndarray 上位ビット
  '''
  def sliceUpperBit(self, x) :
    return (
        x >> (self.M//2)
    )
  
  '''
  下位ビット取得
  @param x    np.ndarray {0, 1, ..., 2^M - 1} データ
  @return x_D np.ndarray 下位ビット
  '''
  def sliceLowerBit(self, x) :
    return x & (
        ( 1 << (self.M//2) ) - 1
    )
  
  '''
  M/2ビットを等間隔に配置
  @param x_           np.ndarray  M/2ビットのデータ
  @return symbolPart   np.ndarray  信号点のI/Q座標
  '''
  def f(self, x_):
    return self.d * (
          x_ * 2 - (
              (1 << (self.M//2) ) - 1
            )
        )
  
  '''
  グレイコードにする
  @param n            array_like integer
  @return              array_like gray coded object
  '''
  def grayEncode(self, n):
    return n ^ n >> 1
  
  '''
  グレイコードから直す
  @param n           array_like gray coded object
  @return             array_like gray decoded object
  '''
  def grayDecode(self, n):
    i = isinstance(n, int)
    n = np.array([n]) if i else n.copy()
    m = n >> 1
    while not (m == 0).all():
        n ^= m
        m >>= 1
    return n[0] if i else n
  
  '''
  信号点配置の表示と電力を計算する
  '''
  def debug(self):
    dataSet = np.arange(1 << self.M)
    dataset = self.grayEncode(dataSet)
    symbolSet = self.modulate(dataSet)

    plt.scatter( symbolSet.real, symbolSet.imag, label = "{}{}".format(1 << self.M, self.mode))
    for n in range(1 << self.M):
      data = dataSet[n]
      symbol = symbolSet[n]
      plt.annotate("${}$".format( format(data, 'b') ), xy = (symbol.real, symbol.imag))

    plt.xlabel("I")
    plt.ylabel("Q")


    plt.legend()
    plt.savefig("{}{}.png".format(
        1 << self.M,
        self.mode  
      )
    )

    plt.show()

    print("calculated power of signal: {}".format(
        math.sqrt(
          np.mean( np.abs(symbolSet) ** 2 )
        )
      )
    )

modulatorTest = Modulator(
    M = 4,
    mode = "QAM",
    isGrayCode = True
)

modulatorTest.debug()

"""### 通信路"""

'''
通信路
'''
class Channel:
  '''
  @param channelMatrix np.ndarray チャネル行列H
  '''
  def __init__(self, channelMatrix):
    self.channelMatrix = channelMatrix
  
  '''
  シンボルsを通信路Hに通して出力( y = Hu 出力)
  @param symbol np.ndarray 入力シンボル
  @reutrn         np.ndarray 出力シンボル
  '''
  def transport(self, symbol):
    return self.channelMatrix @ symbol

'''
クロネッカーモデル通信路
'''
class KroneckerChannel(Channel):
  '''
  @paran Nt   送信アンテナ数
  @paran Nr   受信アンテナ数
  @param rho 相関係数
  @param
  '''
  def __init__(self, Nt, Nr, rho):
    self.Nt = Nt
    self.Nr = Nr
    self.rho = rho
    
    self.Rt = self.Nt * self.exponentialCorrelationMatrix(self.Nt, self.rho)
    self.G = self.gaussianMatrix(self.Nr, self.Nt)
    self.Rr = self.Nr * self.exponentialCorrelationMatrix(self.Nr, self.rho)
    self.kappa = np.trace(self.Rt)


    self.H = self.calcKroneckerChannel(self.Rt, self.G, self.Rr, self.kappa)
  
  def exponentialCorrelationMatrix(self, N, rho):
    mat = np.array([
        [ i - j for j in range(N) ]
        for i in range(N)
    ])
    mat = np.abs(mat)
    mat = np.power(rho, mat)
    return mat
  
  def gaussianMatrix(self, rowNum, colNum):
    mat = np.array([
        [
            random.gauss(mu = 0, sigma = np.sqrt(0.5) ) + 1j * random.gauss(mu = 0, sigma = np.sqrt(0.5) ) 
            for col in range(colNum)
        ]
        for row in range(rowNum)
    ])
    return mat
  
  '''
  H = Rr^{1/2} G ( Rr^{1/2} )^H / \sqrt{\kappa}
  '''
  def calcKroneckerChannel(self, Rt, G, Rr, kappa):
    return sqrtm(Rr) @ G @ (sqrtm(Rt)).conj().T / np.sqrt(kappa)

  def debug(self):
    print("start debug")
    #print( self.exponentialCorrelationMatrix(3, 0) )
    
    Rt = np.zeros( (self.Nt, self.Nt) )
    
    N = 1000
    for n in range(N):
      G = self.gaussianMatrix(self.Nr, self.Nt)
      H = self.calcKroneckerChannel(self.Rt, G, self.Rr, self.kappa)

      Rt_ = H.conj().T @ H

      Rt = Rt + Rt_
    
    Rt /= N
    print("Rt/Nr{}".format( Rt/self.Nr ))


    print("end debug")

"""### 白色ガウス雑音加算器
複素ガウス分布に従う雑音$\boldsymbol{n}$をBox-Muller法で発生させる．
$$
\boldsymbol{n} \sim \mathcal{CN}( 0, \sigma^2  )
$$
実部と虚部は$\mathcal{N}(0, \sigma^2/2)$に従うことに注意
"""

class AwgnAdder:
  '''
  constructor
  '''
  def __init__(self):
    return
  
  '''
  シンボルにガウスノイズn ~ CN(0, σ^2)をのせて返す
  @param symbol  np.ndarray       シンボル
  @param variance float            分散
  @return symbolNoizes np.ndarray ノイズが加算されたシンボル
  '''
  def addAwgn(self, symbol, variance):
    noizeVector = np.array([
          self.generateGaussian(variance) for _ in range(symbol.size)
        ])
    noizeMatrix = noizeVector.reshape( symbol.shape )
    return symbol + noizeMatrix

  ''''
  複素標準ガウス雑音n ~ CN(0, σ^2)生成
  @param variance float     分散σ^2
  @return gaussian complex 複素標準ガウス雑音n ~ CN(0, σ^2)
  '''
  def generateGaussian(self, variance):
    #確率変数x_1, x_2 ~ U(0, 1)
    x_1 = random.uniform(0.0, 1.0)
    x_2 = random.uniform(0.0, 1.0)

    #確率変数x_1, x_2を変換して標準正規分布に従う確率変数y_1, y_2とする
    y_1 = np.sqrt(-2.0 * np.log(x_1)) * np.cos(2.0 * np.pi * x_2)
    y_2 = np.sqrt(-2.0 * np.log(x_1)) * np.sin(2.0 * np.pi * x_2)

    return np.sqrt( variance / 2.0) * (y_1 + 1j * y_2)

"""### 通信路複復号器

***MPSK M$[\rm{bit}]$*** のとき <br>
受け取った信号$y$に対して
$$
\hat{x} = \rm{round} \Bigg( 
  \frac{
  \rm{arg}(y)
}{
  2 \pi / 2^M
} \Bigg)
$$
と復調する．<br>

***MQAM M$[\rm{bit}]$***のとき <br>
受け取った信号$y = y^I + j y^Q$に対して
$$
\hat{x}^{(\cdot)}  = \rm{round}\Bigg(
  \frac{1}{2}
  \bigg\{
    \frac{y^{(\cdot)} }{d} + 2^{M/2} - 1
  \bigg\}
  \Bigg)
$$
として上位ビット$\hat{x}^U$および下位ビット$\hat{x}^D$と復調する. <br>
ただし$\hat{x}^{(\cdot)} < 0$のとき$\hat{x}^{(\cdot)} = 0$, $\hat{x}^{(\cdot)} \geq 2^{M/2}$のとき$\hat{x}^{(\cdot)} = 2^{M/2} - 1$とする．<br>

また，計算量はあるが確実な方法として最小ノルムを指定するシンボルを推定地にする復調法も実装した．すなわち
$$
\hat{x} = \rm{arg min}_{x \in \{0, 1, \cdots, 2^M-1\} } \Big\| \rm{modulate} (x) - y \Big\|
$$
"""

class Demodulator(Modulator):
  '''
  constructor
  @param M              int   多値数[bit] 単位がビットであることに注意
  @param mode          str   変調方式 ex) mode = "PSK", mode = "QAM"
  @param argmin         bool argminで復調するか否か
  @param powerOfSignal float １シンボルあたりの送信電力 (１ビットあたりの送信電力ではない！)
  '''
  def __init__(self,
               M,
               mode,
               isGrayCode = True,
               powerOfSignal  = 1.0,
               argmin = False
               ):
    super().__init__(M, mode, isGrayCode, powerOfSignal)
    self.argmin = argmin
    self.dataOrigin = np.arange(1 << self.M)
    if self.isGrayCode == True:
      self.dataOrigin =  self.grayEncode( self.dataOrigin )
    self.symbolOrigin = self.modulate(self.dataOrigin)
    
    

  '''
  復調
  @param symbolReceived         np.ndarray 受け取ったシンボル
  @return dataDemodulated       np.ndarray 復調されたデータ
  '''
  def demodulate(self, symbolReceived):
    if self.argmin == True:
      dataDemodulated =  np.array([
          np.argmin(
              abs(self.symbolOrigin - symbolReceived_) 
          )
          for symbolReceived_ in symbolReceived
      ])

      if self.isGrayCode == True:
        dataDemodulated = self.grayDecode( dataDemodulated )

    elif self.mode == "PSK":
      dataDemodulated = np.angle( symbolReceived )
      dataDemodulated = dataDemodulated / (
          2.0 * np.pi / ( 1 << self.M )
      )
      dataDemodulated = dataDemodulated.round()
      dataDemodulated = np.array(dataDemodulated.round(), dtype = 'int')
      dataDemodulated = np.where(dataDemodulated < 0,
                                   dataDemodulated + (1 << self.M),
                                   dataDemodulated)
      if self.isGrayCode == True:
        dataDemodulated = self.grayDecode( dataDemodulated )
    
    elif self.mode == "QAM":
      x_U = symbolReceived.real / self.d + (1 << self.M//2) - 1
      x_U /= 2.0
      x_U = x_U.round()
      x_U = np.array(x_U, dtype = 'int')
      x_U = np.where(x_U < 0, 0, x_U)
      x_U = np.where(x_U > ( (1 << self.M//2) - 1), (1 << self.M//2) - 1, x_U)

      x_L = symbolReceived.imag / self.d + (1 << self.M//2) - 1
      x_L /= 2.0
      x_L = x_L.round()
      x_L = np.array(x_L, dtype = 'int')
      x_L = np.where(x_L < 0, 0, x_L)
      x_L = np.where(x_L > ( (1 << self.M//2) - 1), (1 << self.M//2) - 1, x_L)

      if self.isGrayCode == True:
        x_U = self.grayDecode(x_U)
        x_L = self.grayDecode(x_L)
      
      dataDemodulated = (x_U << self.M//2) + x_L
    
    return dataDemodulated
  
  '''
  信号点配置の表示と電力を計算する
  '''
  def debug(self):
    dataSet = np.arange(1 << self.M)
    symbolSet = self.modulate(dataSet)

    dataDemodulated = self.demodulate( symbolSet )
    print("data origin: {}".format(dataSet))
    print("data demodulated {}: ".format(dataDemodulated) )

"""## その他のモジュール

### $\rm{SNR}$もしくは$\frac{E_b}{N_0}$から雑音$\boldsymbol{n} $の分散$\sigma^2$を計算する関数

**SN比から雑音の分散を計算**<br>繰り返し記述しておくが，雑音$ \boldsymbol{n}$の実部，虚部はそれぞれ$\mathcal{N} (0, \sigma^2/2)$に従う.
$$
\rm{SNR} [\mbox{dB}]  = 10 \log_{10} \frac{P_S}{P_N} = 10 \log_{10} \frac{1}{  \sigma^2 }
$$

$$
\therefore
\rm{分散} \sigma^2 = 10^{- \rm{SNR}/10 }
$$

**$\frac{ E_b }{ N_0 }$から雑音の分散を計算**<br>


$$
\begin{cases}
P_S &= M[\rm{bit}] \times E_b \\
\frac{E_b}{N_0} &= 10 \log_{10} \Big( \frac{ E_b }{ \sigma^2 } \Big) 
\end{cases}
$$


$$
\therefore \mbox{分散} \sigma^2 = \frac{P_S}{ M[\rm{bit}] } 10^{
 - E_b/N_0 \big/ 10
}
$$
"""

'''
雑音分散を計算
@param rate          float     SNR or EbN0
@param rateMode    str      "SNR" or "EbN0"
@param M            int      多値数[bit]
@param P_S          float    信号電力
@return variance      float    雑音の分散
'''
def calcVariance(
    rate,
    rateMode,
    M,
    P_S = 1.0
):
  if rateMode == "SNR" :
    return np.power(10.0, - rate / 10.0 )
  
  elif rateMode == "EbN0":
    return P_S / M * np.power(10.0, - rate / 10.0)

"""### SER/BER計算機
送信したデータセットと，復調したデータセットの中身のうち正しく予測したものの割合
"""

'''
SER/BER計算機
@param M              int 多値数[bit]
@param errrorMode     str "SER" or "BER"
'''
class ErrorCalculator:
  def __init__(self, M, errorMode) :
    self.M = M
    self.errorMode = errorMode

  
  '''
  SER or BER計算
  @param dataOrigin        変調する前のデータ
  @param dataDemodulated 復調したデータ
  '''
  def calcError(self,
                dataOrigin,
                dataDemodulated):
    if self.errorMode == "SER":
      return self.calcSER(dataOrigin, dataDemodulated)
    
    elif self.errorMode == "BER":
      return self.calcBER(dataOrigin, dataDemodulated)

  '''
  SER計算
  @param dataOrigin        変調する前のデータ
  @param dataDemodulated 復調したデータ
  '''
  def calcSER(self, 
              dataOrigin,
              dataDemodulated):
    return np.count_nonzero(
        dataOrigin != dataDemodulated
    ) / dataOrigin.size

  '''
  BER計算
  @param dataOrigin        変調する前のデータ
  @param dataDemodulated 復調したデータ
  '''
  def calcBER(self,
              dataOrigin,
              dataDemodulated):
    dataDelta = dataOrigin ^ dataDemodulated
    dataDeltaBits = np.array([
        self.transformBitsFromInt(data)
        for data in dataDelta
        ])
    '''
    or
    dataDeltaBits = self.transformBitsFromInt(data)
    '''

    deltaCnt = np.sum( dataDeltaBits )

    return deltaCnt / dataDeltaBits.size

  '''
  整数を{0,1}^(桁数)に変換
  @param integer          int        変換する整数
  @return bits             np.ndarray 変換された0/1ビット配列
  '''
  def transformBitsFromInt(self, integer):
    return np.array([
        ( integer & (1 << m) ) >> m
        for m in range( self.M )
    ])

"""### SER, BERの理論式

$M$[bit]個のビット列からなるシンボル誤り率$P_{\rm{SER}}$は，ビット誤り率$P_{\rm{BER}}$と
$$
P_\rm{BER} = \frac{2^{M-1}}{2^M - 1} P_\rm{SER}
$$
という関係がある．<br>

**PSK**の理論式
$M = 1$(BPSK)のとき
$$
P_\rm{SER} = \frac{1}{2} \rm{erfc}( \sqrt{\gamma} )
$$

それ以外
$$
P_\rm{SER} \simeq \rm{erfc} \Bigg(\sqrt{\gamma} \sin \frac{\pi}{2^M}\Bigg)
$$

**QAM**の理論式

$$
P_\rm{SER} \simeq 2\Big(1 - \frac{1}{ 2^{M/2} } \Big) \rm{erfc}
\Bigg[ 
\sqrt{ \frac{3}{2(2^M - 1)} \cdot \gamma}
\Bigg]
$$
ただし$\gamma_p$は最大振幅を持つ信号の電力対雑音電力比

あるいは
$$
P_{BER} = P_{SER} if PSK \\
P_{BER} = \alpha \ \rm{erfc}\Big( \sqrt{
  \frac{\gamma}{\beta}
}  \Big)
$$

| | | |
| --- | --- | --- |
|  | $\alpha$ | $\beta$ |
| QPSK | 1/2 | 2 |
| 16QAM | 3/8 | 10 |
| 64QAM | 7/24 | 42 |
| 256QAM | 15/64 | 42 | 
| 1024QAM | 31/160 | 682 |

"""

'''
SNR or Eb/N0によるSER or BERの理論式
@param M            int     多値数[bit]
@param mode        str    "PSK" or "QAM"
@param gammaMode str    "EbN0" or "SNR"
@param gamma      float   SN比
@param errorMode   str    "SER" or "BER"

@return P_e       float 誤り率(P_SER or P_BER)
'''
def errorTheoreticalValue(
    M,
    mode,
    gammaMode,
    gamma,
    errorMode
) :
  if gammaMode == "EbN0":
    gamma *= M
  


  if mode == "PSK":
    P_SER = special.erfc(
        np.sqrt(gamma) * np.sin( np.pi / (1 << M) )
    )
    if M == 1:
      P_SER /= 2
  

  elif mode == "QAM":
    P_SER = 2.0 * (1.0 - 1.0/(1<< M//2) ) * special.erfc( np.sqrt(
          3.0 / (2.0 * ( (1 << M) - 1) ) * gamma
        )
      )



  if errorMode == "SER":
    return P_SER
 

  elif errorMode == "BER":
    if mode == "QAM":
      if M > 10:
        P_BER = P_SER / M
        #P_BER = (1 << (M  - 1)) / ( (1 << M) - 1) * P_SER
      else:  
        if M == 4: #16QAM
          alpha, beta = 3/8, 10
        elif M == 6: #64QAM
          alpha, beta = 7/24, 42
        elif M == 8: #256QAM
          alpha, beta = 15/64, 170
        elif M == 10: #1024QAM
          alpha, beta = 31/160, 682
        P_BER = alpha * special.erfc( np.sqrt( gamma / beta ) )
      
    else: #PSK
      P_BER = P_SER / M
      #P_BER = (1 << (M  - 1)) / ( (1 << M) - 1) * P_SER
 
    return P_BER

"""## Simulation of PSK

### BPSK

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | PSK |
| 多値数 | 2(BPSK) |
|  試行回数  |  100万回  |
|  SNR(=EbN0)  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#変調方式
mode = "PSK"

#多値数
M = 1

#試行回数
informationSize = 1000000

#SNR
rateMode = "SNR"
SNR_MIN = 0
SNR_MAX = 30

#定義域(SNR)
N = (SNR_MAX - SNR_MIN) + 1
SNR = np.linspace(SNR_MIN, SNR_MAX, N)

#送信電力
powerOfSignal = 1.0

"""通信モデル等設定"""

#informationSource = InformationSource()
#encoder = Encoder(M = M)
modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M)

#乱数データ
dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, informationSize])

#データを変調しておく
symbol = modulator.modulate(dataOrigin)

"""#### 実行結果
横軸 SNR:0∼10 [dB]，縦軸 BER(対数表示)のグラフを描く.
"""

BER_SNR_BPSK = np.zeros(shape = SNR.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = SNR[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてBER計算
  ber = errorCalculator.calcBER(dataOrigin, dataDemodulated)

  BER_SNR_BPSK[n] = ber

  print("SNR:{}  BER:{}".format(SNR[n], ber))

np.savetxt("BER_SNR_BPSK.csv",
           np.stack([
               SNR,
               BER_SNR_BPSK
           ])
        )

plt.plot(
    SNR,
    0.5 * special.erfc(
        np.sqrt(
            np.power(10, SNR / 10.0 ) 
        )
    ),
    ':m',
    label = "Theoretical value"
)

plt.plot(
    np.loadtxt("BER_SNR_BPSK.csv")[0],
    np.loadtxt("BER_SNR_BPSK.csv")[1],
    'or',
    label = "BPSK simulated"
)

plt.yscale('log')

plt.xlabel("SNR[dB]")
plt.ylabel("BER")

plt.ylim(10 ** (-5), 1)

plt.legend()

plt.savefig("BER_SNR_BPSK.png")

plt.show()

"""### QPSK

#### SER-Eb/N0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | PSK |
| 多値数 | 4(QPSK) |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#変調方式
mode = "PSK"

#多値数
M = 2

#試行回数
iterationNum = 1000000

#Eb/N0
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

"""通信モデル等設定"""

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M)

#乱数データ
dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, iterationNum])

#データを変調しておく
symbol = modulator.modulate(dataOrigin)

dataOrigin

"""##### 実行結果
横軸 $E_b/N_0$[dB]，縦軸 SER(対数表示)のグラフを描く.
"""

SER_EbN0_QPSK = np.zeros(shape = SNR.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = SNR[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてSER計算
  ser = errorCalculator.calcSER(dataOrigin, dataDemodulated)

  SER_EbN0_QPSK[n] = ser
  print("EbN0 :{} SER:{}".format(EbN0[n], ser) )

np.savetxt("SER_EbN0_QPSK.csv", np.stack([
    EbN0,
    SER_EbN0_QPSK
]))

plt.plot(
    SNR,
    special.erfc( np.sqrt( 1.0/2.0 * 2 * np.power(10, SNR/10.0) ) ) * (
        1.0 - 1.0/4.0 * special.erfc(
        np.sqrt( 1.0/2.0 * 2 * np.power(10, SNR / 10.0 ) )
      )
    )
    ,
    ':c',
    label = "Theoretical value"
)

plt.plot(
    np.loadtxt("SER_EbN0_QPSK.csv")[0],
    np.loadtxt("SER_EbN0_QPSK.csv")[1],
    'ob',
    label = "QPSK simulated"
)

plt.yscale('log')

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("SER")

plt.ylim(10 ** (-6), 1)

plt.legend()

plt.savefig("SER_EbN0_QPSK.png")

plt.show()

"""####  BER - E_b/N_0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | PSK |
| 多値数 | 4(QPSK) |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#誤り基準
errorMode = "BER"

#変調方式
mode = "PSK"

#多値数
M = 2

#試行回数
informationSize = 1000000

#EbN0
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域(SNR)
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M, errorMode = errorMode)

dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, informationSize])
symbol = modulator.modulate(dataOrigin)

BER_EbN0_QPSK = np.zeros(shape = EbN0.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = EbN0[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてBER計算
  ber = errorCalculator.calcError(dataOrigin, dataDemodulated)

  BER_EbN0_QPSK[n] = ber
  print("EbN0: {} BER: {}".format( EbN0[n], ber) )

np.savetxt(path + "/BER_EbN0_QPSK.csv", np.stack([
    EbN0,
    BER_EbN0_QPSK
]))

"""##### 実行結果"""

#理論式
mode = "PSK"
gammaMode = "EbN0"
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)
errorMode = "BER"

plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 2,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':c',
    label = "QPSK Theoretical Value"
)


#実験結果
plt.plot(
    np.loadtxt(path + "/BER_EbN0_QPSK.csv")[0],
    np.loadtxt(path + "/BER_EbN0_QPSK.csv")[1],
    'ob',
    label = "QPSK simulated"
)

plt.yscale('log')

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("BER")

plt.ylim(10 ** (-6), 1)

plt.legend()

plt.savefig(path + "/BER_EbN0_QPSK.png")

plt.show()

"""### 8PSK

#### SER-Eb/N0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | PSK |
| 多値数 | 8 |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#誤り基準
errorMode = "SER"

#変調方式
mode = "PSK"

#多値数
M = 3

#試行回数
iterationNum = 1000000

#Eb/N0
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

"""通信モデル等設定"""

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M, errorMode = errorMode)

#乱数データ
dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, iterationNum])

#データを変調しておく
symbol = modulator.modulate(dataOrigin)

"""##### 実行結果
横軸 $E_b/N_0$[dB]，縦軸 SER(対数表示)のグラフを描く.
"""

SER_EbN0_8PSK = np.zeros(shape = SNR.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = SNR[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてSER計算
  ser = errorCalculator.calcError(dataOrigin, dataDemodulated)

  SER_EbN0_8PSK[n] = ser
  print("EbN0 :{} SER:{}".format(EbN0[n], ser) )

np.savetxt("SER_EbN0_8PSK.csv", np.stack([
    EbN0,
    SER_EbN0_8PSK
]))

EbN0 = np.loadtxt("SER_EbN0_8PSK.csv")[0]

plt.plot(
    EbN0,
    special.erfc(
        np.sqrt( M * np.power(10, EbN0/10.0) ) * 
        np.sin(np.pi/(1<<M))
    )
    ,
    ':y',
    label = "Theoretical value"
)

plt.plot(
    np.loadtxt("SER_EbN0_8PSK.csv")[0],
    np.loadtxt("SER_EbN0_8PSK.csv")[1],
    'og',
    label = "QPSK simulated"
)

plt.yscale('log')

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("SER")

plt.ylim(10 ** (-6), 1)

plt.legend()

plt.savefig("SER_EbN0_8PSK.png")

plt.show()

"""####  BER - E_b/N_0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | PSK |
| 多値数 | 8 |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#誤り基準
errorMode = "BER"

#変調方式
mode = "PSK"

#多値数
M = 3

#試行回数
informationSize = 1000000

#EbN0
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域(SNR)
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M, errorMode = errorMode)

dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, informationSize])
symbol = modulator.modulate(dataOrigin)

BER_EbN0_8PSK = np.zeros(shape = EbN0.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = EbN0[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてBER計算
  ber = errorCalculator.calcError(dataOrigin, dataDemodulated)

  BER_EbN0_8PSK[n] = ber
  print("EbN0: {} BER: {}".format( EbN0[n], ber) )

np.savetxt(path + "/BER_EbN0_8PSK.csv", np.stack([
    EbN0,
    BER_EbN0_8PSK
]))

np.savetxt("BER_EbN0_8PSK.csv", np.stack([
    EbN0,
    BER_EbN0_8PSK
]))

"""##### 実行結果"""

#実験結果
plt.plot(
    np.loadtxt(path + "/BER_EbN0_8PSK.csv")[0],
    np.loadtxt(path + "/BER_EbN0_8PSK.csv")[1],
    'og',
    label = "8PSK simulated"
)


#理論式
mode = "PSK"
gammaMode = "EbN0"
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)
errorMode = "BER"


plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 3,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':y',
    label = "8PSK Theoretical Value"
)


plt.yscale('log')

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("BER")

plt.ylim(10 ** (-6), 1)

plt.legend()

plt.savefig(path + "/BER_EbN0_8PSK.png")

plt.show()

"""## simulation of MQAM

### 16QAM

#### BER-Eb/N0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | QAM |
| 多値数 | 16 |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#誤り基準
errorMode = "BER"

#変調方式
mode = "QAM"

#多値数
M = 4

#試行回数
iterationNum = 1000000

#Eb/N0
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域(SNR)
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M, errorMode = errorMode)

dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, iterationNum])
symbol = modulator.modulate(dataOrigin)

"""実行"""

BER_EbN0_16QAM = np.zeros(shape = EbN0.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = EbN0[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてBER計算
  ber = errorCalculator.calcBER(dataOrigin, dataDemodulated)

  BER_EbN0_16QAM[n] = ber
  print("{} ber: {}".format(EbN0[n], ber) )

#保存
np.savetxt(path + "BER_EbN0_16QAM.csv", np.stack([
    EbN0,
    BER_EbN0_16QAM
]))

path = "/content/drive/My Drive/Colab Notebooks"

np.savetxt(path + "/BER_EbN0_16QAM.csv", np.stack([
    EbN0,
    BER_EbN0_16QAM
]))

"""##### 実行結果"""

#16QAMの実行結果
plt.plot(
    np.loadtxt(path + "BER_EbN0_16QAM.csv")[0],
    np.loadtxt(path + "BER_EbN0_16QAM.csv")[1],
    'or',
    label = "16QAM"
)

plt.yscale('log')

plt.xlim( 0, 30 )
plt.ylim( 5.0 * 10 ** (-5), 1 )

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("BER")

plt.legend()

plt.savefig(path + "/BER_EbN0_16QAM.png")

plt.show()

"""#### SER-Eb/N0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | PSK |
| 多値数 | 16 |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#誤り基準
errorMode = "SER"

#変調方式
mode = "QAM"

#多値数
M = 4

#試行回数
iterationNum = 1000000

#SNR
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M, errorMode = errorMode)

dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, iterationNum])
symbol = modulator.modulate(dataOrigin)

"""実行"""

SER_EbN0_16QAM = np.zeros(shape = EbN0.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = EbN0[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてSER計算
  ser = errorCalculator.calcError(dataOrigin, dataDemodulated)

  SER_EbN0_16QAM[n] = ser
  print("{}/{} ser: {}".format(n, N, ser) )

np.savetxt(path + "/SER_EbN0_16QAM.csv", np.stack([
    EbN0,
    SER_EbN0_16QAM
]))

"""##### 実行結果"""

#16QAMの実行結果
plt.plot(
    np.loadtxt(path + '/SER_EbN0_16QAM.csv')[0],
    np.loadtxt(path + '/SER_EbN0_16QAM.csv')[1],
    'or',
    markersize = 2,
    label = "16QAM"
)

plt.yscale('log')

plt.xlim( 0, 30 )
plt.ylim( 10 ** (-5), 1 )

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("SER")

plt.legend()

plt.savefig(path + "/SER_EbN0_16QAM.png")

plt.show()

"""### 64QAM

#### BER-Eb/N0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | QAM |
| 多値数 | 64 |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#誤り基準
errorMode = "BER"

#変調方式
mode = "QAM"

#多値数
M = 6

#試行回数
iterationNum = 1000000

#Eb/N0
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域(SNR)
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M, errorMode = errorMode)

dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, iterationNum])
symbol = modulator.modulate(dataOrigin)

"""実行"""

BER_EbN0_64QAM = np.zeros(shape = EbN0.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = EbN0[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてBER計算
  ber = errorCalculator.calcError(dataOrigin, dataDemodulated)

  BER_EbN0_64QAM[n] = ber
  print("{} ber: {}".format(EbN0[n], ber) )

np.savetxt(path + "/BER_EbN0_64QAM.csv", np.stack([
    EbN0,
    BER_EbN0_64QAM
]))

"""##### 実行結果"""

#64QAMの実行結果
plt.plot(
    np.loadtxt(path + "/BER_EbN0_64QAM.csv")[0],
    np.loadtxt(path + "/BER_EbN0_64QAM.csv")[1],
    'ob',
    label = "64QAM"
)

plt.yscale('log')

plt.xlim( 0, 30 )
plt.ylim( 5.0 * 10 ** (-5), 1 )

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("BER")

plt.legend()

plt.savefig(path + "/BER_EbN0_64QAM.png")

plt.show()

"""#### SER-Eb/N0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | PSK |
| 多値数 | 16 |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#誤り基準
errorMode = "SER"

#変調方式
mode = "QAM"

#多値数
M = 6

#試行回数
iterationNum = 1000000

#SNR
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M, errorMode = errorMode)

dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, iterationNum])
symbol = modulator.modulate(dataOrigin)

"""実行"""

SER_EbN0_64QAM = np.zeros(shape = EbN0.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = SNR[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてSER計算
  ser = errorCalculator.calcError(dataOrigin, dataDemodulated)

  SER_EbN0_64QAM[n] = ser
  print("{}/{} ser: {}".format(n, N, ser) )

np.savetxt(path + "/SER_EbN0_64QAM.csv", np.stack([
    EbN0,
    SER_EbN0_64QAM
]))

"""##### 実行結果"""

#64QAMの実行結果
plt.plot(
    np.loadtxt(path + '/SER_EbN0_64QAM.csv')[0],
    np.loadtxt(path + '/SER_EbN0_64QAM.csv')[1],
    'ob',
    markersize = 2,
    label = "64QAM"
)

plt.yscale('log')

plt.xlim( 0, 30 )
plt.ylim( 10 ** (-5), 1 )

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("SER")

plt.legend()

plt.savefig(path + "/SER_EbN0_64QAM.png")

plt.show()

"""### 256QAM

#### BER-Eb/N0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | QAM |
| 多値数 | 256 |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#誤り基準
errorMode = "BER"

#変調方式
mode = "QAM"

#多値数
M = 8

#試行回数
iterationNum = 1000000

#Eb/N0
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域(SNR)
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M, errorMode = errorMode)

dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, iterationNum])
symbol = modulator.modulate(dataOrigin)

"""実行"""

BER_EbN0_256QAM = np.zeros(shape = EbN0.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = EbN0[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてBER計算
  ber = errorCalculator.calcError(dataOrigin, dataDemodulated)

  BER_EbN0_256QAM[n] = ber
  print("{} ber: {}".format(EbN0[n], ber) )

np.savetxt(path + "/BER_EbN0_256QAM.csv", np.stack([
    EbN0,
    BER_EbN0_256QAM
]))

"""##### 実行結果"""

#256QAMの実行結果
plt.plot(
    np.loadtxt(path + "/BER_EbN0_256QAM.csv")[0],
    np.loadtxt(path + "/BER_EbN0_256QAM.csv")[1],
    'og',
    label = "256QAM"
)

plt.yscale('log')

plt.xlim( 0, 30 )
plt.ylim( 5.0 * 10 ** (-5), 1 )

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("BER")

plt.legend()

plt.savefig(path + "/BER_EbN0_256QAM.png")

plt.show()

"""#### SER-Eb/N0

パラメータ

|    |    |
| ---- | ---- |
| 変調方式 | PSK |
| 多値数 | 256 |
|  試行回数  |  100万回  |
|  $E_b/N_0$  |  0[dB]~30[dB]  |
| 送信電力 | 1 |
"""

#誤り基準
errorMode = "SER"

#変調方式
mode = "QAM"

#多値数
M = 8

#試行回数
iterationNum = 1000000

#SNR
rateMode = "EbN0"
EbN0_MIN = 0
EbN0_MAX = 30

#定義域
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)

#送信電力
powerOfSignal = 1.0

modulator = Modulator(M = M, mode = mode, powerOfSignal = powerOfSignal)
channel = Channel(channelMatrix = np.array([1]) )
awgnAdder = AwgnAdder()
demodulator = Demodulator(M = M, mode = mode, powerOfSignal = powerOfSignal)

errorCalculator = ErrorCalculator(M = M, errorMode = errorMode)

dataOrigin = np.random.randint(low = 0, high = 1 << M, size = [1, iterationNum])
symbol = modulator.modulate(dataOrigin)

"""実行"""

SER_EbN0_256QAM = np.zeros(shape = EbN0.shape)

for n in range(N):
  #シンボルsを通信路Hに通しノイズnをのせる
  symbolTransported = channel.transport(symbol)

  symbolNoized = awgnAdder.addAwgn(
                                    symbolTransported, 
                                    calcVariance(
                                        rate = SNR[n], rateMode = rateMode,
                                        M = M, P_S = powerOfSignal)
                                  )
  
  #復調
  dataDemodulated = demodulator.demodulate(symbolNoized)

  #元のデータと復調データを照らし合わせてSER計算
  ser = errorCalculator.calcError(dataOrigin, dataDemodulated)

  SER_EbN0_256QAM[n] = ser
  print("{}/{} ser: {}".format(n, N, ser) )

np.savetxt(path + "/SER_EbN0_256QAM.csv", np.stack([
    EbN0,
    SER_EbN0_256QAM
]))

"""##### 実行結果"""

#256QAMの実行結果
plt.plot(
    np.loadtxt(path + '/SER_EbN0_256QAM.csv')[0],
    np.loadtxt(path + '/SER_EbN0_256QAM.csv')[1],
    'og',
    markersize = 2,
    label = "256QAM"
)

plt.yscale('log')

plt.xlim( 0, 30 )
plt.ylim( 10 ** (-5), 1 )

plt.xlabel("$E_b/N_0$[dB]")
plt.ylabel("SER")

plt.legend()

plt.savefig(path + "/SER_EbN0_256QAM.png")

plt.show()

"""## まとめ

### PSK

#### BER-Eb/N0
"""

#実験結果
plt.plot(
    np.loadtxt(path + "/BER_SNR_BPSK.csv")[0],
    np.loadtxt(path + "/BER_SNR_BPSK.csv")[1],
    'or', 
    label = "BPSK"
)

plt.plot(
    np.loadtxt(path + "/BER_EbN0_QPSK.csv")[0],
    np.loadtxt(path + "/BER_EbN0_QPSK.csv")[1],
    'ob',
    label = "QPSK"
)

plt.plot(
    np.loadtxt(path + "/BER_EbN0_8PSK.csv")[0],
    np.loadtxt(path + "/BER_EbN0_8PSK.csv")[1],
    'og',
    label = "8PSK"
)

#理論式
mode = "PSK"
gammaMode = "EbN0"
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)
errorMode = "BER"

plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 1,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':m',
    label = "BPSK Theoretical Value"
)
plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 2,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':c',
    label = "QPSK Theoretical Value"
)
plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 3,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':y',
    label = "8PSK Theoretical Value"
)


plt.xlabel("$E_b/N_0$")
plt.ylabel("BER")

plt.yscale("log")

plt.xlim(0, 15)
plt.ylim(10 ** (-5), 1)

plt.title("$E_b/N_0$-BER (PSK)")

plt.legend()


plt.savefig(path + "/BER_EbN0_PSK.png")

"""#### SER-Eb/N0"""

#実験結果
plt.plot(
    np.loadtxt(path + "/BER_SNR_BPSK.csv")[0],
    np.loadtxt(path + "/BER_SNR_BPSK.csv")[1],
    'or', 
    label = "BPSK"
)
plt.plot(
    np.loadtxt(path + "/SER_EbN0_QPSK.csv")[0],
    np.loadtxt(path + "/SER_EbN0_QPSK.csv")[1],
    'ob',
    label = "QPSK"
)
plt.plot(
    np.loadtxt(path + "/SER_EbN0_8PSK.csv")[0],
    np.loadtxt(path + "/SER_EbN0_8PSK.csv")[1],
    'og',
    label = "8PSK"
)

#理論式
mode = "PSK"
gammaMode = "EbN0"
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)
errorMode = "SER"

plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 1,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':m',
    label = "BPSK Theoretical Value"
)
plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 2,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':c',
    label = "QPSK Theoretical Value"
)
plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 3,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':y',
    label = "8PSK Theoretical Value"
)

plt.xlabel("$E_b/N_0$")
plt.ylabel("SER")

plt.yscale("log")

plt.xlim(0, 15)
plt.ylim(10 ** (-5), 1)

plt.title("$E_b/N_0$-SER (PSK)")

plt.legend()


plt.savefig(path + "/SER_EbN0_PSK.png")

"""### QAM

#### BER-EbN0
"""

#実験結果
plt.plot(
    np.loadtxt(path + "/BER_EbN0_16QAM.csv")[0],
    np.loadtxt(path + "/BER_EbN0_16QAM.csv")[1],
    'or', 
    label = "16QAM"
)
plt.plot(
    np.loadtxt(path + '/BER_EbN0_64QAM.csv')[0],
    np.loadtxt(path + '/BER_EbN0_64QAM.csv')[1],
    'ob',
    label = "64QAM"
)
plt.plot(
    np.loadtxt(path + "/BER_EbN0_256QAM.csv")[0],
    np.loadtxt(path + "/BER_EbN0_256QAM.csv")[1],
    'og',
    label = "256QAM"
)


#理論式
mode = "QAM"
gammaMode = "EbN0"
EbN0_MIN, EbN0_MAX = 0, 31
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)
errorMode = "BER"

plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 4,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':m',
    label = "16QAM Theoretical Value"
)
plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 6,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':c',
    label = "64QAM Theoretical Value"
)
plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 8,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':y',
    label = "256PSK Theoretical Value"
)


plt.xlabel("$E_b/N_0$")
plt.ylabel("BER")

plt.yscale("log")

plt.ylim(10 ** (-5), 1)

plt.title("$E_b/N_0$-BER (QAM)")

plt.legend()

plt.savefig(path + "/BER_EbN0_QAM.png")

"""#### SER-Eb/N0"""

#実験結果
plt.plot(
    np.loadtxt(path + "/SER_EbN0_16QAM.csv")[0],
    np.loadtxt(path + "/SER_EbN0_16QAM.csv")[1],
    'or', 
    label = "16QAM"
)
plt.plot(
    np.loadtxt(path + '/SER_EbN0_64QAM.csv')[0],
    np.loadtxt(path + '/SER_EbN0_64QAM.csv')[1],
    'ob',
    label = "64QAM"
)
plt.plot(
    np.loadtxt(path + "/SER_EbN0_256QAM.csv")[0],
    np.loadtxt(path + "/SER_EbN0_256QAM.csv")[1],
    'og',
    label = "256QAM"
)


#理論式
mode = "QAM"
gammaMode = "EbN0"
N = (EbN0_MAX - EbN0_MIN) + 1
EbN0 = np.linspace(EbN0_MIN, EbN0_MAX, N)
errorMode = "SER"

plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 4,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':m',
    label = "16QAM Theoretical Value"
)
plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 6,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':c',
    label = "64QAM Theoretical Value"
)
plt.plot(
    EbN0,
    errorTheoreticalValue(
        M = 8,
        mode = mode,
        gammaMode = gammaMode,
        gamma = np.power(10.0, EbN0/10.0),
        errorMode = errorMode
    ),
    ':y',
    label = "256PSK Theoretical Value"
)

plt.xlabel("$E_b/N_0$")
plt.ylabel("SER")

plt.yscale("log")

#plt.xlim(0, 15)
plt.ylim(10 ** (-5), 1)

plt.title("$E_b/N_0$-SER (QAM)")

plt.legend()

plt.savefig(path + "/SER_EbN0_QAM.png")